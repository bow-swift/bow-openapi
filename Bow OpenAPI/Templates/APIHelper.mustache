//
//  APIHelper.swift
//
//  Generated by bow-openapi
//  Copyright Â© {{generatedYear}} Bow Authors. All rights reserved.
//

import Foundation
import BowEffects

public extension API {
    
    enum Helper {
        public static func mapValuesItems(_ source: [String: Any?]) -> [String: String] {
            return source.reduce(into: [String: String]()) { (result, item) in
                if let collection = item.value as? [Any] {
                    result[item.key] = collection.compactMap { "\($0)" }.joined(separator: ",")
                } else if let value = item.value {
                    switch value {
                    case let x as Bool:
                        result[item.key] = x.description
                    default:
                        result[item.key] = "\(value)"
                    }
                }
            }
        }
        
        public static func mapValuesToQueryItems(_ source: [String: Any?]) -> [URLQueryItem]? {
            let destination = mapValuesItems(source).reduce(into: [URLQueryItem]()) { (result, item) in
                result.append(URLQueryItem(name: item.key, value: item.value))
            }
            
            return destination.isEmpty ? nil : destination
        }
        
        public static func send<T: Codable>(request: URLRequest, session: URLSession, decoder: ResponseDecoder) -> IO<API.HTTPError, T> {
            return session.dataTaskIO(with: request)
                          .mapLeft { error in .other(error: error) }
                          .flatMap { response, data in
                                guard let httpResponse = response as? HTTPURLResponse else {
                                    return IO.raiseError(.malformedURL(response: response, data: data))
                                }
                            
                                do {
                                    switch httpResponse.statusCode {
                                    case 200 ..< 300:
                                        let result = try decoder.decode(T.self, from: data)
                                        return IO.pure(result)
                                    case 400:
                                        return IO.raiseError(.badRequest(response: response, data: data))
                                    case 403:
                                        return IO.raiseError(.forbidden(response: response, data: data))
                                    case 404:
                                        return IO.raiseError(.notFound(response: response, data: data))
                                    case 500:
                                        return IO.raiseError(.serverError(response: response, data: data))
                                    case 503:
                                        return IO.raiseError(.serviceUnavailable(response: response, data: data))
                                    default:
                                        return IO.raiseError(.unknown(response: response, data: data))
                                    }
                                } catch {
                                    return IO.raiseError(.parsingError(response: response, data: data))
                                }
                          }^
        }
    }
}
