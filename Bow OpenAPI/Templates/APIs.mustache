//
//  APIs.swift
//
//  Generated by bow-openapi
//  Copyright Â© {{generatedYear}} Bow Authors. All rights reserved.
//

import Foundation

public enum API {}


/// Definition of `Config` to set up the API Client
extension API {

    public struct Config {
        let basePath: String
        let httpHeader: API.HTTPHeader
        let additionalHeaders: [String: String]
        
        init (basePath: String, httpHeader: API.HTTPHeader = .json, additionalHeaders: [String: String] = [String: String]()) {
            self.basePath = basePath
            self.httpHeader = httpHeader
            self.additionalHeaders = additionalHeaders
        }
    }
}

/// Definition of HTTP Headers for the content type
extension API {

    public enum HTTPHeader: String {
        case json = "application/json"
        
        public var contentType: [String: String] {
            return ["Accept": rawValue,
                    "Content-Type": rawValue]
        }
    }
}

/// A description of possible errors happened while performing an HTTP network request.
extension API {
    
    public enum HTTPError: Error, Equatable {
        case malformedURL(response: URLResponse, data: Data)
        case parsingError(response: URLResponse, data: Data)
        case badRequest(response: URLResponse, data: Data)          // HTTP 400
        case forbidden(response: URLResponse, data: Data)           // HTTP 403
        case notFound(response: URLResponse, data: Data)            // HTTP 404
        case serverError(response: URLResponse, data: Data)         // HTTP 500
        case serviceUnavailable(response: URLResponse, data: Data)  // HTTP 503
        case unknown(response: URLResponse, data: Data)
        case other(error: Error)
        
        public var error: Error {
            guard case let .other(error) = self else { return self }
            return error
        }
        
        public var dataError: (response: URLResponse, data: Data)? {
            switch self {
            case let .malformedURL(response, data): return (response, data)
            case let .parsingError(response, data): return (response, data)
            case let .badRequest(response, data): return (response, data)
            case let .forbidden(response, data): return (response, data)
            case let .notFound(response, data): return (response, data)
            case let .serverError(response, data): return (response, data)
            case let .serviceUnavailable(response, data): return (response, data)
            case let .unknown(response, data): return (response, data)
            default:
                return nil
            }
        }
        
        public static func == (lhs: HTTPError, rhs: HTTPError) -> Bool {
            let lhsError = lhs.error
            let rhsError = rhs.error
            let lhsData = lhs.dataError
            let rhsData = rhs.dataError
            
            return lhsError._code == rhsError._code &&
                   lhsError._domain == rhsError._domain &&
                   lhsData?.response == rhsData?.response &&
                   lhsData?.data == rhsData?.data
        }
    }
}
