//
//  Configuration.swift
//
//  Generated by bow-openapi
//  Copyright Â© {{generatedYear}} Bow Authors. All rights reserved.
//

import Foundation


/// Definition of `Config` to set up the API Client
extension API {
    public struct Config {
        public let basePath: String
        public let headers: [String: String]
        public let session: URLSession
        
        public init (basePath: String, session: URLSession = .shared) {
            self.init(basePath: basePath, headers: [:], session: session)
        }
        
        private init (basePath: String, headers: [String: String], session: URLSession) {
            self.basePath = basePath
            self.headers = headers
            self.session = session
        }
        
        func copy(basePath: String? = nil, headers: [String: String]? = nil, session: URLSession? = nil) -> API.Config {
            return API.Config(basePath: basePath ?? self.basePath,
                              headers: headers ?? self.headers,
                              session: session ?? self.session)
        }
        
        var contentType: API.ContentType {
            API.ContentType(rawValue: headers["Content-Type"]?.lowercased() ?? "") ?? .json
        }
    }
}


/// Definition of HTTP Headers for the content type
extension API {
    public enum ContentType: String {
        case json = "application/json"
        
        var headers: [String: String] {
            return ["Accept": rawValue,
                    "Content-Type": rawValue]
        }
    }
}


/// A description of possible errors happened while performing an HTTP network request.
extension API {
    public enum HTTPError: Error, Equatable {
        case malformedURL(response: URLResponse, data: Data)
        case parsingError(response: URLResponse, data: Data)
        case badRequest(response: URLResponse, data: Data)          // HTTP 400
        case forbidden(response: URLResponse, data: Data)           // HTTP 403
        case notFound(response: URLResponse, data: Data)            // HTTP 404
        case serverError(response: URLResponse, data: Data)         // HTTP 500
        case serviceUnavailable(response: URLResponse, data: Data)  // HTTP 503
        case unknown(response: URLResponse, data: Data)
        case other(error: Error)
        
        public var error: Error {
            guard case let .other(error) = self else { return self }
            return error
        }
        
        public var dataError: (response: URLResponse, data: Data)? {
            switch self {
            case let .malformedURL(response, data): return (response, data)
            case let .parsingError(response, data): return (response, data)
            case let .badRequest(response, data): return (response, data)
            case let .forbidden(response, data): return (response, data)
            case let .notFound(response, data): return (response, data)
            case let .serverError(response, data): return (response, data)
            case let .serviceUnavailable(response, data): return (response, data)
            case let .unknown(response, data): return (response, data)
            default:
                return nil
            }
        }
        
        public static func == (lhs: HTTPError, rhs: HTTPError) -> Bool {
            let lhsError = lhs.error
            let rhsError = rhs.error
            let lhsData = lhs.dataError
            let rhsData = rhs.dataError
            
            return lhsError._code == rhsError._code &&
                   lhsError._domain == rhsError._domain &&
                   lhsData?.response == rhsData?.response &&
                   lhsData?.data == rhsData?.data
        }
    }
}


/// MARK: - public alias
public typealias BigDecimal = Decimal
